CREATE OR REPLACE PROCEDURE P_DWA_V_M_4G_LOST_MID2(V_MONTH   IN VARCHAR2,
                                                    V_PROV IN VARCHAR2,
                                                    V_RETCODE OUT VARCHAR2,
                                                    V_RETINFO OUT VARCHAR2) IS
  /*%
     *********************************************************
  *名称 --%@杜娅丽:
  *功能描述 --%@4G稳定度模型指标处理:
  *执行周期 --%@PERIOD:月
  *参数 --%@PARAM:V_MONTH 当月 YYYYMM
  *创建人 --%@杜娅丽:
  *创建时间 --%@2015-05-25:
  *层次---%@LEVEL:DWA层
  *主题域---%@MASTER_FIELD:
  *备注 --%@REMARK:
  *修改记录 --%@MODIFY:
  *所属于实体--%@ENTITY:
  *来源表 --%@FROM:
  *来源表 --%@FROM:
  *来源表 --%@FROM:
  *来源表 --%@FROM:
  *来源表 --%@FROM:
  *来源表 --%@FROM:
  *目标表 --%@TO:
     **************************************************************
  %*/
  V_PKG      VARCHAR2(30);
  V_TAB      VARCHAR2(300);
  V_PROCNAME VARCHAR2(300);
  V_ROWLINE  NUMBER;
  V_COUNT    NUMBER;
  V_MONTH1   VARCHAR(6);
  V_MONTH2   VARCHAR(6);
  V_MONTH3   VARCHAR(6);
  V_MONTH4   VARCHAR(6);
  V_MONTH5   VARCHAR(6);
  V_MONTH6   VARCHAR(6);
/*  V_CNT      NUMBER;*/
  V_SQL      LONG;
  V_LOG_SN   NUMBER;
 /* V_DATE     VARCHAR2(8);*/
BEGIN
  V_PKG      := 'LOST_4G'; -- 分类
  V_TAB      := 'MID_V_M_4G_LOST_2';
  V_PROCNAME := 'P_DWA_V_M_4G_LOST_MID2'; -- 过程名称
/*  V_DATE  := TO_CHAR(LAST_DAY(TO_DATE(V_MONTH,'YYYYMM')),'YYYYMMDD');*/
  V_MONTH1   := TO_CHAR(ADD_MONTHS(TO_DATE(V_MONTH,'YYYYMM'),-1),'YYYYMM');
  V_MONTH2   := TO_CHAR(ADD_MONTHS(TO_DATE(V_MONTH,'YYYYMM'),-2),'YYYYMM');
  V_MONTH3   := TO_CHAR(ADD_MONTHS(TO_DATE(V_MONTH,'YYYYMM'),1),'YYYYMM');
  V_MONTH4   := TO_CHAR(ADD_MONTHS(TO_DATE(V_MONTH,'YYYYMM'),2),'YYYYMM');
  V_MONTH5   := TO_CHAR(ADD_MONTHS(TO_DATE(V_MONTH,'YYYYMM'),3),'YYYYMM');
  V_MONTH6   := TO_CHAR(ADD_MONTHS(TO_DATE(V_MONTH,'YYYYMM'),-5),'YYYYMM');
  SELECT ZB_CSM.SEQ_DWD_SQLPARSER.NEXTVAL
      INTO V_LOG_SN --运行日志序号
      FROM DUAL;
  --日志部分
  P_INSERT_SQLPARSER_LOG_GENERAL(V_LOG_SN,V_MONTH,V_PROV,'ZB_DWA',V_PROCNAME,'V_DATE='||V_MONTH||';V_PROV='||V_PROV ,SYSDATE,V_TAB);
  P_INSERT_LOG(V_MONTH ,V_PKG,V_PROCNAME,V_PROV,SYSDATE,V_TAB);

  --条件判断
   SELECT COUNT(1) INTO V_COUNT FROM MID_V_M_4G_LOST_1
    WHERE MONTH_ID = V_MONTH
    AND PROV_ID = V_PROV
    AND ROWNUM < 11;

IF V_COUNT = 10 THEN

         V_SQL := 'ALTER TABLE ZB_CSM.MID_V_M_4G_LOST_2 TRUNCATE SUBPARTITION PART'||V_MONTH||'_SUBPART'||V_PROV ;
      execute immediate v_sql;

V_SQL := 'INSERT INTO ZB_CSM.MID_V_M_4G_LOST_2
SELECT
MONTH_ID,
PROV_ID,
AREA_ID,
CUST_ID,
SUBS_INSTANCE_ID,
DEVICE_NUMBER,
SERVICE_TYPE,
IS_FREE,
IS_TEST,
IS_AGREE,
IS_INNET,
IS_SANWU,
IS_LOWER_VALUE_USER,
USER_STATUS,
CASE WHEN PRODUCT_TYPE = ''01000'' THEN 1
  WHEN PRODUCT_TYPE IN (''030400'',''060100'') THEN 2
    WHEN PRODUCT_TYPE IN (''030100'',''030200'') THEN 3
    ELSE 4
      END PRODUCT_TYPE,
CASE WHEN CHANNEL_TYPE = ''02'' THEN ''02''
  ELSE ''01''
    END CHANNEL_TYPE,
CASE WHEN LAST_STOP_DATE > '''||V_MONTH||''' THEN 0
  WHEN LAST_STOP_DATE < '''||V_MONTH6||''' OR LAST_STOP_DATE IS NULL THEN 6
    ELSE MONTHS_BETWEEN(TO_DATE('''||V_MONTH||''',''YYYYMM''),TO_DATE(LAST_STOP_DATE,''YYYYMM''))
      END LAST_STOP_DATE,
CASE WHEN INNET_MONTH IS NULL OR INNET_MONTH <=1 THEN ROUND(LN(7),2)
  WHEN INNET_MONTH > 10 AND INNET_MONTH < 13 THEN ROUND(LN(INNET_MONTH-3),2)
  WHEN INNET_MONTH > 60 THEN ROUND(LN(61),2)
  ELSE ROUND(LN(INNET_MONTH + 1),2)
    END INNET_MONTH,
CASE WHEN AGREE_EXP_DATE IN ('''||V_MONTH1||''','''||V_MONTH2||''','''||V_MONTH||''','''||V_MONTH3||''','''||V_MONTH4||''','''||V_MONTH5||''') THEN 1
  ELSE 0
    END AGREE_EXP,
CASE WHEN TERM_TYPE = ''3G'' THEN ''3G''
  WHEN TERM_TYPE = ''4G'' THEN ''4G''
  ELSE ''2G''
    END TERM_TYPE,
CASE WHEN USE_STATUS_INNET = ''7'' THEN 1
  WHEN USE_STATUS_INNET IN (''4'',''5'') THEN 2
    ELSE 3
      END USE_STATUS_INNET,
NVL(LAST_IS_ACCT,0) LAST_IS_ACCT,
NVL(IF_MBTOCB,0) IF_MBTOCB,
CASE WHEN MEMBER_LVL IS NULL OR MEMBER_LVL = ''99'' THEN 0
  ELSE 1
    END MEMBER_LVL,
CASE WHEN CALL_RATIO IS NULL OR ROUND(CALL_RATIO,2) <= 0 THEN 1
  WHEN ROUND(CALL_RATIO,2) >= 11 THEN 1
    WHEN ROUND(CALL_RATIO,2) > 0 AND ROUND(CALL_RATIO,2) < 1 THEN 1-ROUND(CALL_RATIO,2)
  ELSE (ROUND(CALL_RATIO,2) - 1)/10
    END CALL_RATIO,
CASE WHEN STREAM_RATIO IS NULL OR ROUND(STREAM_RATIO,2) <= 0 THEN 0.9
  WHEN ROUND(STREAM_RATIO,2) >= 30 THEN (30-0.9)/10
    WHEN ROUND(STREAM_RATIO,2) > 0 AND ROUND(STREAM_RATIO,2) < 0.9 THEN 0.9-ROUND(STREAM_RATIO,2)
  ELSE (ROUND(STREAM_RATIO,2)-0.9)/10
    END STREAM_RATIO,
CASE WHEN ACCT_FEE IS NULL OR ROUND(ACCT_FEE) <= 50 THEN 1
    ELSE 0
      END ACCT_FEE,
CASE WHEN JF_TIMES IS NULL OR JF_TIMES < 0 THEN 0
  WHEN JF_TIMES > 750 THEN ROUND(LN(751),2)
  ELSE ROUND(LN(JF_TIMES+1),2)
    END JF_TIMES,
CASE WHEN P2P_SMS_CNT IN (0,1,2,3) THEN 0
  ELSE 1
    END P2P_SMS_CNT,
CASE WHEN TOTAL_FLUX IS NULL OR TOTAL_FLUX < 0 THEN 0
  WHEN ROUND(TOTAL_FLUX) > 2000 THEN ROUND(LN(2001),2)
  ELSE ROUND(LN(ROUND(TOTAL_FLUX)+1),2)
    END TOTAL_FLUX,
CASE WHEN total_flux < 1 or (total_flux_4g + total_flux_3g ) > total_flux THEN 0
  WHEN ROUND((total_flux_4g + total_flux_3g )/total_flux,1) IS NULL THEN 0
  ELSE ROUND((total_flux_4g + total_flux_3g )/total_flux,1)
    END FLUX_34G_CN,
CASE WHEN ACCT_CN IS NULL OR ROUND(ACCT_CN,2) < -1 THEN 1
  WHEN ROUND(ACCT_CN,2) > 1 THEN 1.01
  WHEN ROUND(ACCT_CN,2) >= -1 AND ROUND(ACCT_CN,2) < -0.04 THEN 0-ROUND(ACCT_CN,2)
    WHEN ROUND(ACCT_CN,2) > 0.04 AND ROUND(ACCT_CN,2) <= 1 THEN ROUND(ACCT_CN,2)-0
      WHEN ROUND(ACCT_CN,2) >= -0.04 AND ROUND(ACCT_CN,2) < 0 THEN 0-ROUND(ACCT_CN,2)+0.19
        ELSE ROUND(ACCT_CN,2)-0+0.19
      END ACCT_CN,
CASE WHEN FLUX_CN IS NULL OR ROUND(FLUX_CN,2) < -1 THEN 1
  WHEN ROUND(FLUX_CN,2) > 10 THEN 1.01
  WHEN ROUND(FLUX_CN,2) >= -1 AND ROUND(FLUX_CN,2) < -0.04 THEN 0-ROUND(FLUX_CN,2)
    WHEN ROUND(FLUX_CN,2) > 0.04 AND ROUND(FLUX_CN,2) <= 10 THEN (ROUND(FLUX_CN,2)-0)/10
      WHEN ROUND(FLUX_CN,2) >= -0.04 AND ROUND(FLUX_CN,2) < 0 THEN 0-ROUND(FLUX_CN,2)+0.81
        ELSE ROUND(FLUX_CN,2)-0+0.81
      END FLUX_CN,
CASE WHEN TIMES_CN IS NULL OR ROUND(TIMES_CN,2) < -1 THEN 1
  WHEN ROUND(TIMES_CN,2) > 5 THEN 0.51
  WHEN ROUND(TIMES_CN,2) >= -1 AND ROUND(TIMES_CN,2) < -0.04 THEN 0-ROUND(TIMES_CN,2)
    WHEN ROUND(TIMES_CN,2) > 0.04 AND ROUND(TIMES_CN,2) <= 5 THEN (ROUND(TIMES_CN,2)-0)/10
      WHEN ROUND(TIMES_CN,2) >= -0.04 AND ROUND(TIMES_CN,2) < 0 THEN 0-ROUND(TIMES_CN,2)+0.49
        ELSE ROUND(TIMES_CN,2)-0+0.49
      END TIMES_CN,
CASE WHEN VALID_CALL_RING IS NULL OR VALID_CALL_RING < 1 THEN 0
  WHEN VALID_CALL_RING > 32 THEN ROUND(LN(33),2)
  ELSE ROUND(LN(VALID_CALL_RING+1),2)
    END VALID_CALL_RING,
CASE WHEN YIWANG_CNT IS NULL OR YIWANG_CNT < 0 THEN 0
  WHEN ROUND(YIWANG_CNT) > 170 THEN ROUND(LN(171),2)
  ELSE ROUND(LN(ROUND(YIWANG_CNT)+1),2)
    END YIWANG_CNT,
CASE WHEN NET_TYPE IN (''3'',''4'') THEN 1
  ELSE 0
    END NET_TYPE,
CASE WHEN MANU_NAME = ''Apple'' THEN 1
      ELSE 0
        END MANU_NAME,
ROUND(DEV_NUM_SHANG,2) DEV_NUM_SHANG
FROM MID_V_M_4G_LOST_1
WHERE MONTH_ID = '''||V_MONTH||'''
AND PROV_ID = '''||V_PROV||'''

';
    EXECUTE IMMEDIATE V_SQL;
    V_ROWLINE := SQL%ROWCOUNT;
    COMMIT;


    V_RETCODE := 'SUCCESS';
    V_RETINFO := '结束';
ELSE
    V_RETCODE := 'WAIT';
    V_RETINFO := '等待数据';
END IF;



  -- 更新执行结果
  P_UPDATE_LOG(V_MONTH ,
               V_PKG,
               V_PROCNAME,
               V_PROV,
               V_RETINFO,
               V_RETCODE,
               SYSDATE,
               V_ROWLINE);
               P_UPDATE_SQLPARSER_LOG_GENERAL(V_LOG_SN, V_RETCODE, V_RETINFO);
EXCEPTION
  WHEN OTHERS THEN
    V_RETCODE := 'FAIL';
    V_RETINFO := SQLERRM;
    P_UPDATE_LOG(V_MONTH ,
                 V_PKG,
                 V_PROCNAME,
                 V_PROV,
                 V_RETINFO,
                 V_RETCODE,
                 SYSDATE,
                 V_ROWLINE);
                 P_UPDATE_SQLPARSER_LOG_GENERAL(V_LOG_SN, V_RETCODE, V_RETINFO);
END;
/
